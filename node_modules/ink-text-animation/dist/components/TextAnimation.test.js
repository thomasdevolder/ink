'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _ink = require('ink');

var _renderToString = require('ink/lib/render-to-string');

var _renderToString2 = _interopRequireDefault(_renderToString);

var _chalkAnimation = require('chalk-animation');

var _chalkAnimation2 = _interopRequireDefault(_chalkAnimation);

var _TextAnimation = require('./TextAnimation');

var _TextAnimation2 = _interopRequireDefault(_TextAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getAnimationFrame = (name, i) => {
  const animation = _chalkAnimation2.default[name]('This is a text').stop();
  animation.f = i;

  return animation.frame();
};

const getComponentFrames = (props, numberOfFrames = 50) => {
  let tree;
  let component;

  const frames = [];

  const setRef = ref => {
    component = ref;
  };

  for (let i = 0; i < numberOfFrames; i += 1) {
    tree = (0, _ink.build)((0, _ink.h)(
      _TextAnimation2.default,
      _extends({ ref: setRef }, props),
      'This is a text'
    ), tree);

    frames.push((0, _renderToString2.default)(tree));
    component.update();
  }

  // Make sure the component will unmount
  tree = (0, _ink.build)(null, tree);

  return frames;
};

describe('<TextAnimation />', () => {
  it('should render', () => {
    getComponentFrames().forEach((frame, i) => {
      expect(getAnimationFrame('rainbow', i)).toContain(frame);
    });
  });

  it('should allow changing the animation', () => {
    getComponentFrames({ name: 'pulse' }).forEach((frame, i) => {
      expect(getAnimationFrame('pulse', i)).toContain(frame);
    });
  });
});